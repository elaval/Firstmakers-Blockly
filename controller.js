'use strict';
/* jshint undef: true, unused: true */
/* global angular */




/**
 * @ngdoc controller
 * @name chilecompraApp.controller:CarrerasController
 * @requires $scope
 * @requires chilecompraApp.CarrerasDataService
 *
 * @property {array} colorOptions Array with options for colorAttributes
 * @property {string} colorAttribute Selected color attribute
 * @property {array} data Array with student data for the selected career & semester
 * @property {int} n Number of students in the selected data array
 * @property {int} maxCarreras Maximum number of carreras to be displayed when filtraTopCarreras is true
 * @property {array} semestres Array with the semesters options to be chosen
 * @property {string} selectedSemestre Selected semester for data selection
 * @property {string} psuValido Flag to select only data values with a valid psu score (prom_paa>0)
 * @property {string} loading Flag to show a "loading" message when its value is true
 * @description
 *
 * Controller for Carreras explorer
 *
 */
angular.module('tideApp')
.controller('AppController', ['$scope','$http','$timeout','$log','$q','$window',
        '$interval','$uibModal','$translate','_','d3', 'BlocklyService', 
        'BoardService','SerialService','VirtualBoardService',
        'DeviceService','DeviceCommandService',
    function ($scope,$http,$timeout,$log,$q,$window,
        $interval,$uibModal,$translate,_,d3, BlocklyService, 
        BoardService,SerialService, VirtualBoardService,
        DeviceService, DeviceCommandService) 
    {
	var myself = this;
    
    // Public functions (accesible from the view)
    myself.runCode = runCode
    myself.disconnectBoard = disconnectBoard
    myself.scanPorts = scanPorts;
    myself.softReset = softReset;
    myself.changeLanguage = onChangeLanguage;
    myself.onInjected = onInjected;
    myself.clearBlocks = clearBlocks;
    myself.updateBlocks = updateBlocks;

    // Public properties (accesible from the view)
    myself.workspace = null; // Blockly workspace generated by <blockly> directive
    myself.statusMessageText; // Message to be displyes to the user
    myself.state = {whiteLight: false} // state of virtual board
    myself.boardState = {
        connected: false,
        connecting: false,
        port:null,
    }
    
    myself.blocklyOptions = null;
    myself.virtualBoard = null;
    myself.physicalBoard = null;
    
    // Local variables/properties
    var physicalDevice = null;
    var virtualDevice = null;
    var pinState = {};
   
    // Init controller
    activate()
    
    // Controler's 'constructor'
    function activate() {
        
        // Retreive stored language definition
        var langKey = $translate.storage().get($translate.storageKey());
        if (!langKey) langKey = "es";
        
        setLanguage(langKey)
        .then(function() {
            initBlockly();
        })
        
        myself.virtualBoard = VirtualBoardService.createVirtualBoard();
        virtualDevice = DeviceService.createDevice(myself.virtualBoard);
        DeviceCommandService.setVirtualDevice(virtualDevice);
        
        scanPorts();
    }
 
    // Implementation of public methods
    // ==================================
    
    $interval(function() {

        updateBlocks();
    }, 100);
    

    
    /**
     * updates customValues in blocks
     */
    function updateBlocks() {
        if (physicalDevice) {
            if (myself.physicalBoard) {
                myself.physicalBoard.digitalRead(2, function(value) {
                    physicalDevice.sensorValues().button = value === myself.physicalBoard.HIGH; 

                })
                console.log(myself.physicalBoard.pins[2]);
            }
                
            
            var blocks = myself.workspace.getAllBlocks();
            for (var i = 0, block; block = blocks[i]; i++) {
                block.updateSensor && block.updateSensor(physicalDevice.sensorValues());
            }
        }
    }

    /**
     * Runs the Blockly code
     */
    function runCode() {
        BlocklyService.runCode(myself.workspace);
    }
    
    /**
     * Disconnects a physical board
     */
    function disconnectBoard() {
        BoardService.disconnect(true);
    }
    
    /**
     * Resets the program 
     */
    function softReset() {
        window.location.reload();
    }
    
    /**
     * Scans for available ports and if found, attempts to open a new board
     */
    function scanPorts() {
        SerialService.Serial.detect(function(ports) {
            connectBoard(ports);
        });
    }
    
    /**
     * Function to be called when a change language action (ie menu selection) is triggered
     */
    function onChangeLanguage(langKey) {
        setLanguage(langKey)
        .then(function() {
            initBlockly();
        })
    }
    
    
    /**
     * Sets the interface language
     */
    function setLanguage(langKey) {
        var deferred = $q.defer();
        
        myself.selectedLanguage = langKey;
        $translate.use(langKey);
      
         // Load Blockly's language strings.

        // Load msg definitions for the specified language (Ex msg/js/en.js)
        $http.get('./bower_components/google-blockly/msg/js/'+langKey+'.js')
        .then(function(res) {
            var blocklyMainMsgCode = res.data;
            eval(blocklyMainMsgCode);
            
            // Load firstmakers msg definitions for the specified language (Ex msg/js/en.js)
            return $http.get('./translations/firstmakersBlocks/'+langKey+'.js')
        })
        .then(function(res) {
            var blocklyFirstmakersMsgCode = res.data;
            eval(blocklyFirstmakersMsgCode);
            deferred.resolve();
        })
        .catch(function(err) {
            deferred.reject(err);
        }) 
        
        return deferred.promise;
    }


    // Implementation of private methods
    // ==================================
   

    function statusMessage() {
        var msg = "";
        
        if (myself.boardState.connected) {
            msg = "STATUS_MESSAGE_CONNECTED";
        } else if (!myself.boardState.connected && myself.boardState.connecting) {
            msg = "STATUS_MESSAGE_CONNECTING";
        } else {
            msg = "STATUS_MESSAGE_NOT_CONNECTED";
        }
        
        return msg;
    }
    
    /**
     * Creates Blockly options and initiates Blockly workspace/stage
     */
    function initBlockly() {
        var options
        
        BlocklyService.getOptions("./toolbox.xml")
        .then(function(_options){
            options = _options;
            
            return translateToolboxCategories(options.toolbox);
        })
        .then(function(translatedToolbox) {
            
            options.toolbox = translatedToolbox;
            
            myself.blocklyOptions = options;
            $log.debug(myself.blocklyOptions);
        })
    }
    
    /**
     * Load blocks saved in session/local storage.
     * @param {string} defaultXml Text representation of default blocks.
     */
    function loadBlocks(defaultXml) {
        
        try {
            var savedBlocks = $window.localStorage.savedBlocks;
        } catch(e) {
            var saveBlocks = null;
        }
        
        if (savedBlocks) {
            // Load the editor with previously saved blocks.
            var xml = Blockly.Xml.textToDom(savedBlocks);
            Blockly.Xml.domToWorkspace(xml, myself.workspace);
        } else if (defaultXml) {
            // There are no previously saved blocks ...
            // Load the editor with default starting blocks.
            var xml = Blockly.Xml.textToDom(defaultXml);
            Blockly.Xml.domToWorkspace(xml, myself.workspace);
        }
    };
    
    /**
     * Save the current blocks - in the workspace - in the browsers localStorage.
     */
    function saveBlocks() {
        if (typeof Blockly != 'undefined' && myself.workspace) {
            var xml = Blockly.Xml.workspaceToDom(myself.workspace);
            var text = Blockly.Xml.domToText(xml);
            $window.localStorage.savedBlocks = text;
        }
    }
    
    /**
     * Clears blocks from the workspace
     */
    function clearBlocks() {
        $translate('CONFIRM_CLEAR_MSG').then(function (messageTxt) {
            if (myself.workspace && confirm(messageTxt)) {
            myself.workspace.clear();
            }
        });

    }
    
    /**
     * Called each time the workspace changes assignec to change listener in onInjected
     */
    function onWorkspaceChange(e) {
        saveBlocks();
    }
    
    /**
     * Function called (from blockly directive) when a new blockly definition & workspace is created
     */
    function onInjected(workspace) {
        myself.workspace = workspace;
        
        // Listen to changes in the workspace & call onChangeWorkspace 
        myself.workspace.addChangeListener(onWorkspaceChange);
   
        
        // Load default code in case that there a workspace has not been previously saved
        var defaultXml =
          '<xml>' +
          '  <block type="light_on" deletable="true" x="70" y="70">' +
          '  </block>' +
          '</xml>';
        loadBlocks(defaultXml);
    }
    
    /**
     * Attempts to connect available ports
     */
    function connectBoard(ports) {
        var firstPort = ports[0];
        myself.boardState.connecting = true;
        myself.boardState.port = firstPort;
        
        BoardService.connect(firstPort)
        .then(function(board) {
            // Successful connection with first port!! (Yeah)
            myself.physicalBoard = board;
             
            physicalDevice = DeviceService.createDevice(myself.physicalBoard);
            physicalDevice.activatePinMonitor();
            
            DeviceCommandService.setPhysicalDevice(physicalDevice);
            
            myself.boardState.connecting = false;
            myself.boardState.connected = true;
        })
        .catch(function(err) {
            // Unsuccesful connection to first port
            // Let's 'lock' it and try with the rest of the ports
            myself.boardState.connecting = false;
            myself.boardState.connected = false;
            
            // TODO: Check if error seems to correspond to a non-firmata valid board or a "hanged" port and send a message
            SerialService.Serial.lock(firstPort);
            if (ports.length > 1) {  
                // Removes first port from the list of ports and tries again
                ports = _.rest(ports);
                connectBoard(ports);
            } else {
                // We tried - unsuccessfully with all ports, let's scan again 
                scanPorts();
            }
            $log.error(err);
        });
    }
    
    /**
     * Translates names of toolbox categories
     * Returns a promise to the translated xml text
     */
    function translateToolboxCategories(toolboxText) {
        var deferred = $q.defer();
        
        var xml = Blockly.Xml.textToDom(toolboxText);
        $log.debug(xml);
        
        var translationPromises = [];
        
        _.each(xml.getElementsByTagName("category"), function(node) {
            translationPromises.push(translateNodeName(node));
        })
        
        $q.all(translationPromises)
        .then(function(res) {
            $log.debug(res);
        })
        .catch(function(err) {
            $log.error(err);
        })
        .finally(function(d) {
            $log.debug(d);
            $log.debug(xml);
            var toolboxText = Blockly.Xml.domToText(xml);
            $log.debug(toolboxText);
            deferred.resolve(toolboxText);
        })
        
        return deferred.promise;
        
    }
    
    /**
     * Translate the name attribute of an xml node 
     * Returns a promise to the translated node
     */
    function translateNodeName(node) {
        var deferred = $q.defer();
        
        var originalName = node.getAttribute("name");
        $translate(originalName)
        .then(function(translatedName) {
            node.setAttribute("name", translatedName);
            deferred.resolve(node);
        })
        .catch(function(err) {
            deferred.reject(err);
        })
        
        return deferred.promise;
    }
    

    /**
     * Handles board.closed event 
     * Triggered when board is disconnected (cable pulled)
     * or when the board is automatically closed (for example due to an errror)
     */
    $scope.$on("board.closed", function(e,a) {
        myself.boardState.connected = false;
        
        physicalDevice = null;
        DeviceCommandService.setPhysicalDevice(physicalDevice);
        myself.physicalBoard = null;
        
        scanPorts();
        $log.debug(a);
    })
    

    /**
     * Firstmakers sensor
     */
    function firstmakersSensor() {
        var board;
        var sensors = {};
        
        sensors.setBoard = function(_board) {
            board = _board;
            
            return sensors
        }
        
        sensors.potentiometer = function() {
            var pinValue = board && board.pins ? board && board.pins[19].value : 0;
            var value = Math.floor(100*pinValue/1023);
            
            return value; 
        }
        
        return sensors
    }
    
    
    /**
     * Modal window (for future use)
     */
    var open = function (size, ports) {

        var modalInstance = $uibModal.open({
        animation: true,
        templateUrl: 'templates/modal.html',
        controller: 'ModalInstanceCtrl',
        size: size ? size : 'sm',
        resolve: {
            items: function () {
                return ports;
            }
        }
        });

        modalInstance.result.then(function (selectedItem) {
            $scope.selected = selectedItem;
        }, function () {
            $log.info('Modal dismissed at: ' + new Date());
        });
    };
    
    
    $scope.$watch(statusMessage,
        function handleStatusChange( newValue, oldValue ) {
            myself.statusMessageText = newValue;
            $log.debug( "statusMessage", newValue );
        }
    );
    
    
    
                
                
}]);

angular.module('tideApp')
.controller('ModalInstanceCtrl', function ($scope, $uibModalInstance, items) {

  $scope.items = items;
  $scope.selected = {
    item: $scope.items[0]
  };

  $scope.ok = function () {
    $uibModalInstance.close($scope.selected.item);
  };

  $scope.cancel = function () {
    $uibModalInstance.dismiss('cancel');
  };
});
