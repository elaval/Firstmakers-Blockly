'use strict';
/* jshint undef: true, unused: true */
/* global angular */




/**
 * @ngdoc controller
 * @name chilecompraApp.controller:CarrerasController
 * @requires $scope
 * @requires chilecompraApp.CarrerasDataService
 *
 * @property {array} colorOptions Array with options for colorAttributes
 * @property {string} colorAttribute Selected color attribute
 * @property {array} data Array with student data for the selected career & semester
 * @property {int} n Number of students in the selected data array
 * @property {int} maxCarreras Maximum number of carreras to be displayed when filtraTopCarreras is true
 * @property {array} semestres Array with the semesters options to be chosen
 * @property {string} selectedSemestre Selected semester for data selection
 * @property {string} psuValido Flag to select only data values with a valid psu score (prom_paa>0)
 * @property {string} loading Flag to show a "loading" message when its value is true
 * @description
 *
 * Controller for Carreras explorer
 *
 */
angular.module('tideApp')
.controller('AppController', ['$scope','$http','$timeout','$log','$q',
        '$interval','$uibModal','$translate','_','d3', 'DataService', 'BlocklyService', 
        'BoardService','SerialService','VirtualBoardService',
        'DeviceService','DeviceCommandService',
    function ($scope,$http,$timeout,$log,$q,
        $interval,$uibModal,$translate,_,d3, dataService, BlocklyService, 
        BoardService,SerialService, VirtualBoardService,
        DeviceService, DeviceCommandService) 
    {
	var myself = this;
    
    // Public functions (accesible from the view)
    myself.runCode = runCode
    myself.disconnectBoard = disconnectBoard
    myself.scanPorts = scanPorts;
    myself.softReset = softReset;
    myself.changeLanguage = onChangeLanguage;

    // Public properties (accesible from the view)
    myself.workspace = null; // Blockly workspace generated by <blockly> directive
    myself.statusMessageText; // Message to be displyes to the user
    myself.state = {whiteLight: false} // state of virtual board
    myself.boardState = {
        connected: false,
        connecting: false,
        port:null,
    }
    
    myself.blocklyOptions = null;
    myself.virtualBoard = null;
    myself.physicalBoard = null;
    
    // Local variables/properties
    var physicalDevice = null;
    var virtualDevice = null;
   
    // Init controller
    activate()
    
    // Controler's 'constructor'
    function activate() {
        
        // Retreive stored language definition
        var langKey = $translate.storage().get($translate.storageKey());
        if (!langKey) langKey = "es";
        
        setLanguage(langKey)
        .then(function() {
            initBlockly();
        })
        
        myself.virtualBoard = VirtualBoardService.createVirtualBoard();
        virtualDevice = DeviceService.createDevice(myself.virtualBoard);
        DeviceCommandService.setVirtualDevice(virtualDevice);
        
        scanPorts();
    }
 
    // Implementation of public methods
    // ==================================
    

    /**
     * Runs the Blockly code
     */
    function runCode() {
        BlocklyService.runCode(myself.workspace);
    }
    
    /**
     * Disconnects a physical board
     */
    function disconnectBoard() {
        BoardService.disconnect(true);
    }
    
    /**
     * Resets the program 
     */
    function softReset() {
        window.location.reload();
    }
    
    /**
     * Scans for available ports and if found, attempts to open a new board
     */
    function scanPorts() {
        SerialService.Serial.detect(function(ports) {
            connectBoard(ports);
        });
    }
    
    function onChangeLanguage(langKey) {
        setLanguage(langKey)
        .then(function() {
            initBlockly();
        })
    }
    
    
    /**
     * Sets the interface language
     */
    function setLanguage(langKey) {
        var deferred = $q.defer();
        
        myself.selectedLanguage = langKey;
        $translate.use(langKey);
      
         // Load Blockly's language strings.

        // Load msg definitions for the specified language (Ex msg/js/en.js)
        $http.get('./bower_components/google-blockly/msg/js/'+langKey+'.js')
        .then(function(res) {
            var blocklyMainMsgCode = res.data;
            eval(blocklyMainMsgCode);
            
            // Load firstmakers msg definitions for the specified language (Ex msg/js/en.js)
            return $http.get('./translations/firstmakersBlocks/'+langKey+'.js')
        })
        .then(function(res) {
            var blocklyFirstmakersMsgCode = res.data;
            eval(blocklyFirstmakersMsgCode);
            deferred.resolve();
        })
        .catch(function(err) {
            deferred.reject(err);
        }) 
        
        return deferred.promise;
    }


    // Implementation of private methods
    // ==================================
   

    function statusMessage() {
        var msg = "";
        
        if (myself.boardState.connected) {
            msg = "STATUS_MESSAGE_CONNECTED";
        } else if (!myself.boardState.connected && myself.boardState.connecting) {
            msg = "STATUS_MESSAGE_CONNECTING";
        } else {
            msg = "STATUS_MESSAGE_NOT_CONNECTED";
        }
        
        return msg;
    }
    
    /**
     * Creates Blockly options and initiates Blockly workspace/stage
     */
    function initBlockly() {
        BlocklyService.getOptions("./blocks.xml")
        .then(function(options){
            myself.blocklyOptions = options;
            $log.debug(myself.blocklyOptions);
        })
    }
    
    /**
     * Attempts to connect available ports
     */
    function connectBoard(ports) {
        var firstPort = ports[0];
        myself.boardState.connecting = true;
        myself.boardState.port = firstPort;
        
        BoardService.connect(firstPort)
        .then(function(board) {
            // Successful connection with first port!! (Yeah)
            myself.physicalBoard = board;
            physicalDevice = DeviceService.createDevice(myself.physicalBoard);
            DeviceCommandService.setPhysicalDevice(physicalDevice);
            
            myself.boardState.connecting = false;
            myself.boardState.connected = true;
        })
        .catch(function(err) {
            // Unsuccesful connection to first port
            // Let's 'lock' it and try with the rest of the ports
            myself.boardState.connecting = false;
            myself.boardState.connected = false;
            
            // TODO: Check if error seems to correspond to a non-firmata valid board or a "hanged" port and send a message
            SerialService.Serial.lock(firstPort);
            if (ports.length > 1) {  
                // Removes first port from the list of ports and tries again
                ports = _.rest(ports);
                connectBoard(ports);
            } else {
                // We tried - unsuccessfully with all ports, let's scan again 
                scanPorts();
            }
            $log.error(err);
        });
    }
    

    /**
     * Handles board.closed event 
     * Triggered when board is disconnected (cable pulled)
     * or when the board is automatically closed (for example due to an errror)
     */
    $scope.$on("board.closed", function(e,a) {
        myself.boardState.connected = false;
        
        physicalDevice = null;
        DeviceCommandService.setPhysicalDevice(physicalDevice);
        
        scanPorts();
        $log.debug(a);
    })
    

    $scope.$on("virtualFirstmakersChange", function(e,pins){
        $timeout(0).then(function() {myself.state.whiteLight = pins[13];})
        
    });
    
    /**
     * Modal window (for future use)
     */
    var open = function (size, ports) {

        var modalInstance = $uibModal.open({
        animation: true,
        templateUrl: 'templates/modal.html',
        controller: 'ModalInstanceCtrl',
        size: size ? size : 'sm',
        resolve: {
            items: function () {
                return ports;
            }
        }
        });

        modalInstance.result.then(function (selectedItem) {
            $scope.selected = selectedItem;
        }, function () {
            $log.info('Modal dismissed at: ' + new Date());
        });
    };
    
    
    $scope.$watch(statusMessage,
        function handleStatusChange( newValue, oldValue ) {
            myself.statusMessageText = newValue;
            $log.debug( "statusMessage", newValue );
        }
    );
    
    
    
                
                
}]);

angular.module('tideApp')
.controller('ModalInstanceCtrl', function ($scope, $uibModalInstance, items) {

  $scope.items = items;
  $scope.selected = {
    item: $scope.items[0]
  };

  $scope.ok = function () {
    $uibModalInstance.close($scope.selected.item);
  };

  $scope.cancel = function () {
    $uibModalInstance.dismiss('cancel');
  };
});
